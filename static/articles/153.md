<!-- title:僕はなぜここまでして猫をメニューバーで走らせたかったのか... -->

# はじめに

こんにちは。趣味で macOS アプリ開発をしている学生デベロッパの Kyome と申します。今回は、CPU 負荷に合わせた速度でメニューバー上で猫が走るだけの macOS 向けユーティリティ(?)アプリ、[RunCat](https://kyome.io/runcat/index_jp.html)をリリースしてから約一周年ということで、RunCat の開発裏話を記しておこうと思います。

# RunCat

> 「なんか面白いアプリ作りたいな〜。」
> 「この前はカスタムキーボードでピアノ作ったし、マニアックなとこ攻めたいな。メニューバーとか...。」
> Mac Book を開き、ふとメニューバーを見ると、Wi-Fi の接続チェック中のアニメーションが目に入る
> 「へぇ...メニューバーってアニメーションできるのか。」
> 「...猫でも走らせてみようか。」

すべてはこんな思いつきから始まりました。

**RunCat**は CPU 負荷に合わせて Runner と呼ばれるキャラクター（あるいはモチーフ）のアニメーション再生速度が変化する、システム・インフォメーション・インジケーターです。

![runcat_demo.gif](./images/article/e6d7a2ed-89c6-ead0-68ed-bf4dccf656db.gif)

↑ 基本的にはこんな感じで猫が走るアニメーションが無限に再生されるだけのアプリです。

![Screen Shot 2019-12-24 at 21.10.43.png](./images/article/a5f0c36b-4831-1b93-f9a0-1ba507591064.png)

現在では、CPU の負荷に加え、メモリパフォーマンス、ディスク容量、ネットワークスピードの情報を閲覧できる機能も加わり、ちょっと本格的な Stats 系アプリに成長しています。機能縮小版に関してはオープンソース化されています。→[menubar_runcat](https://github.com/Kyome22/menubar_runcat)

機能がミニマムなアプリだし、さぞ簡単に実装もできるだろうと一見思えるのですが、どっこいこれがそうでもなかったのです...。

# 前編：リリースまでの歩み

## そもそも常駐型のメニューバーアプリってどう作るのよ？

macOS アプリエンジニアの数は非常に少なく、iOS と違って知見もなかなか見つからない界隈です。しかも、常駐型のメニューバーアプリなんてマニアックな分野になったらなおさら文献は少なく、やっと見つけたいくつかの記事もみんな俺実装をしていて何が正しいのかわからないなんてことはザラでした。かくして猫を走らせようという軽い思いつきは、いきなり壁にぶち当たりました。今思えば、なぜここで引き下がらなかったのかが不思議です。暇じゃなかったはずなのに...。でも諦めない！だってこのアイデアは形にしたいから！

ということで、常駐型メニューバーアプリ作成の基本の要点だけまとめます。

1. `TARGET`の`info.plist`に`Application is agent (UIElement)`または`Application is background only`の Key を追加して、Value を YES にする
2. `Main.storyboard`の`WindowController`および`ViewController`を削除
3. メニューバーにプリセットされている不要な項目を削除

![Screen Shot 2019-12-24 at 21.42.59.png](./images/article/84f2f7c5-8e5b-d1f3-667d-20467f84c5bf.png)

4. `Application Scene`に`Menu`を追加して、`AppDelegateと紐づける`

![Screen Shot 2019-12-24 at 21.53.12.png](./images/article/1cfcc612-bcf4-c9ea-db1d-9c42f628c235.png)

5. `Menu`に`Menu Item`を２つ追加し，タイトルを About と Quit にして、それぞれ`FirstResponder`の`orderFrontStandardAboutPanel`と`terminate`に繋ぐ

![Screen Shot 2019-12-24 at 21.58.09.png](./images/article/27f1cd49-bf14-0d45-277a-9c00838c3126.png)

![Screen Shot 2019-12-24 at 21.58.20.png](./images/article/9b5e7907-7c88-7ce1-67f9-30cc58c902e0.png)

6. `AppDelegate`にて最小限の設定

```swift:AppDelegate.swift
@NSApplicationMain
class AppDelegate: NSObject, NSApplicationDelegate {

    @IBOutlet weak var menu: NSMenu!
    let statusItem = NSStatusBar.system.statusItem(withLength: NSStatusItem.variableLength)
    var button: NSStatusBarButton!

    func applicationDidFinishLaunching(_ aNotification: Notification) {
        statusItem.menu = menu
        button = statusItem.button!
        button.title = "Moji" // アイコンの方がベター
        button.image = NSImage(named: "アイコン画像") //　アイコン画像の仕様については後述
    }

}
```

こんな感じで基礎の基礎はできます。

## メニューバーで猫が走った！でもつまらない...

とりあえずメニューバーアプリの基礎を組むことができた私は、走る猫の 5 コマアニメを用意して`Timer`を使って`NSStatusBarButton`の image を 0.2 秒ごとにループで切り替えるという単純実装をしてみたのでした。

...猫が走ってる！ ...でもなんか面白くない。

そう。思っていたよりも面白くなかったのです。
永遠と一定の速度で走る猫は見ていてすぐに飽きることに気づいた私は、何かに基づいて走る速度が変わるようにしようと思いました。

### マウスカーソルの移動に合わせて猫が走るようにしてみた

まずやってみたことは、マウスカーソルの移動量に応じて、コマ送りをするという案です。当然ですが、常駐型アプリなので、アプリがバックグラウンドになっている時も動いてくれないと面白くありません。そこでグローバルな環境でマウスイベントを取る必要が出てきました。マウスのムーブイベントを取るのは`NSEvent`を使えば難しくありません。

```swift
var monitors = [Any?]()

func setMonitor() {
    monitors.append(NSEvent.addLocalMonitorForEvents(matching: .mouseMoved, handler: { (event) -> NSEvent? in
        let location = NSEvent.mouseLocation
        return event
    }))
    monitors.append(NSEvent.addGlobalMonitorForEvents(matching: .mouseMoved, handler: { (event) in
        let location = NSEvent.mouseLocation
    }))
}

func removeMonitor() {
    for monitor in monitors {
        NSEvent.removeMonitor(monitor!)
    }
    monitors.removeAll()
}
```

このようにして、ある閾値以上マウスが動いた場合に 1 フレームコマが送られるようにしたところ、素早くマウスを動かせば猫が必死に走り、ゆっくりマウスを動かせば猫がゆっくり走るようになりました。かなりよくなりました。ただ、常にマウスを動かしている訳でもありません。何かいい方法はないでしょうか...

### キーボードの入力ごとに猫が走るようにしてみた（かった...）

ということで、執筆中にも猫を走らせたいと思い、キー入力イベントごとに猫が走るようにしようとしました。調子よくタイピングしているときは猫が軽快に走り、そうでないときは止まる感じですね。これも基本的には`NSEvent.addGlobalMonitorForEvents`に`NSEvent.EventTypeMask.keyDown`を使えばできるようになるはずなのですが、アクセシビリティ制限の壁があったのです。環境設定の「セキュリティーとプライバシー」の中のアクセシビリティでアプリによるキー入力の取得の許可をユーザから得ないといけませんでした。また、この手法は AppStore でリリースするアプリでは使えないものです。このアイデアについては仕方なく引き下がりました。トホホ

## App Rejected: 4. 2 Design: Minimum Functionality

とにもかくにも、猫が走るようになったのですからひとまずリリースしてみようと思い、アップデート申請をしたところ、審査結果はリジェクト：Minimum Functionality でした。知らない方もいるかもしれませんが、要は「**お前のアプリクソすぎて AppStore には載せらんないわ，出直してきな！」**ということでした。そりゃそうです。猫がマウスの動きに合わせて走ったところでなんの役に立つというのか。AppStore の審査員はそのバージョンに関しては不変らしいので、審査員をどうにかして納得させないといけません。しかし課題は一度出たらもうリリースは諦めた方が良いとまで恐れられる Minimum Functionality です。私は匙を投げました。

### とりあえずオープンソースにして Qiita の記事を雑に投げた

リリースできなさそうだと踏んだ私は、早々に諦めて GitHub にオープンソースとして公開することにしました。そして、そのリンクを貼った Qiita の記事を書いてこのネタは終わりにしようと思ったのです（なぜか記事を消してしまいました...）。

## そして 2 ヶ月ほど過ぎたある日

Qiita の記事に「猫を CPU に合わせて走らせてみては？」とコメントが届いていることに気づきました。

「なるほどそれは面白そうだし機能的にも意味がありそうだ！」

再びリリースへの挑戦心が復活しました。

### CPU 負荷に応じて猫が走るようにしたい！

早速開発作業に取り掛かった私は、CPU 負荷を取ってくる方法を調査し始めました。

「...そんな文献全然出てこないんだけど！！」

そう、ただでさえ前例や文献の少ない macOS アプリ開発界隈、CPU 負荷を取得するなんて文献がホイホイ出てくるわけがないのです。しかし諦めすにネットを彷徨うこと 1 ヶ月強、[SystemKit](https://github.com/beltex/SystemKit)という強そうなソースコードを発見し、それを参考にしながら無事に CPU 負荷を取得することができたのでした。

## リリース開始！

その後も何度かリジェクトを食らうなど、紆余曲折あったものの、無事に 2018 年 11 月 21 日にリリースをすることができました。
猫だけではダメだったようで、犬やうさぎやドラゴンなどの初期メンバーを足すことになりました。

### 恐るべきバズり!!

なんとたった約一週間で 2600 ダウンロードされました。iOS 市場はよく分かりませんが、macOS 市場でしかも個人でとなるとこれは異常でした！！（私にとっては） これまでコツコツ育てて 2 年ほどかけてようやく 1000 ダウンロード行ったアプリ達がバカみたいでした（ユーザの役に立っているかどうかは別として）。

![Screen Shot 2019-12-24 at 23.02.02.png](./images/article/b6e6d856-f32f-0893-9a37-53a41d3d5e69.png)

そこで私は悟ったのです。

> 「時代は猫なんだな...」
> 「とりあえずバズらせたいなら猫をモチーフに使えばいいんじゃないかな？」

# 後編：アップデートとバグフィックス

## Runner 有料化からのクレームの嵐

猫のバズりが落ち着いたある日、研究室の後輩に言われました

> 「なんで稼がないんですか？勿体無い」

確かにそうです。言われるまで、あまり欲がなかったのですが、なんか勿体無い気がしてきたのと、App 内課金の実装に興味があったことから、何かしら有料機能をつけることを考え始めました。そして、後輩から様々なアドバイスを受けて、Runner（アニメーションのキャラクター）を小売やパック売りにするというのをやってみることにしたのです。

### macOS 向けの App 内課金の実装例、全然見つからないんだが

またしても文献が少ない問題が発生！iOS の例はいっぱいあるけど macOS のはない...てか無知すぎてそもそも同じ API でできるのかもわからない！という状態でした。そんな感じでも、ものは試しだと iOS の例を真似っこしながら実装したところ、コードは動いていそうな感じ。あとは App Store Connect の設定だ！

参考にした記事：[Swift4.0 非消耗型課金を簡単に行う IAP マネージャクラスを作ってみた](https://qiita.com/KikurageChan/items/5c9c0b4a6c6c6ddb26c4)

### App Store Connect の設定とか、審査とか、SandBox テストとかわからん

わからないことだらけですが、めげている場合ではありません。iTunes Connect から App Store Connect に変わったり、UI や仕組みが変わったりしていましたが、先行文献と照らし合わせながらのトライ＆エラーの繰り返し。

参考になる記事：[iOS アプリ開発辞典/アプリ内課金の実装方法](https://terakoya.site/ios_dic/ios-dic-in-app-purchese/)

### やった!App 内課金ができたぞ！！ ...ん？

何を思ったのか、私は無償で使えていた Runner 達のいくつか（というかほとんど）を有料にして、その代わりに少数の新規無料 Runner を追加するという暴挙に出ていました。それからの一ヶ月は**クレームの嵐！**もともと無料のアプリだったというのにも関わらず、目を覆いたくなるような罵詈雑言が私に刺さりました（汗

以下、レビューの抜粋（翻訳含む）

- アプリの楽しさが取り除かれたので、アンインストール必須！
- 金の亡者
- 有料になったのは**一部**じゃなくて**全部**じゃねぇか！
- 失望しました
- はめられた！
- 恐ろしいことが起きた
- アップデートしなかったら良かったです
- インストールすることをオススメしない
- アプリを**削除**しました
- **課金を説明に書かないクズ、詐欺アップデート、アンインストール推奨、最低最悪**

ちなみにクレームっぽいレビューの 8 割は中国語で書かれていました。単純に人口が多いからなのか、無料アプリに対する評価がシビアなお国柄なのかはわかりません。

### 大反省...でも一度内課金にしたら戻せないじゃん

多くのファンをがっかりさせてしまい、大反省した私にできることといえば、アップデートによる機能の充実と、無料 Runner の追加でした。暇があればひたすらコマ送りアニメーションのネタを考えてはドット絵をポチポチし、メニューバーで実際に動かしては、修正したりボツにしたりの繰り返し。そうして徐々に増やして行った結果、今では Runner が有料・無料合わせて**６０種類！！**（バカなのか？）でも、アップデートを重ねるうちにクレーマーの熱も冷め、今では全世界での評価は星 4 つ ★★★★☆ です。なんとか（精神的に）耐えましたね。

## アップデート頻発からのクレーム

当時何も考えずに Sierra、High Sierra、Mojave の 3 バージョンにてリリースしていたのですが、なんとデバッグを Mojave でしかしていなかったのです。メニューバーはかなり特殊なので、当然 OS のバージョンごとに仕様がかなり異なっており、不具合の報告が相次ぎました。にも関わらず、「ゆうて Sierra と High Sierra はあんまり変わらんだろ」と思って Sierra と High Sierra の実装を分けずにバグフィックスしたのが最悪で、あっちを直せばこっちがダメになり、こっちを直せばあっちがダメでといった現象が起きました（テスト版ではなくリリース版で、です）。その結果、10 日間に 4 度のアップデートという仏もブチ切れるほどのアップデートを強行してしまったのです。そして届くクレーム！

- もうアップデート無くて良いです
- アップデート多すぎ糞
- もう使いませんのでご自分の都合でご自分が満足するまでアップデートしまくってください

**本当に申し訳ありませんでしたっ！　 m(\_ \_)m**

## 速度の調整可能な軽量なアニメーションを実装したかっただけなのに...

RunCat は常駐型アプリなので常に動いています。しかも、CPU 負荷を表示する存在。そんな RunCat 自身が CPU 負荷を圧迫していたら大変です！

### Timer での実装：メニューバーにした途端処理重くなるのなんでなん？

一番最初は Timer を二重に使ってコマ送りアニメーションを実装していました。片方は 5 秒間隔で動くタイマーで、処理ごとに CPU 負荷を取得して猫のスピード（コマ送りのインターバル）を計算します。もう片方のタイマーは先の処理に合わせて一時停止し、インターバールを更新した上でコマ送りを再開すると行った感じ。これは、普通の View で動かす分には軽量（0.1%）で、CPU 負荷を全然食わないのですが、メニューバーとなると話が変わってきます。急に CPU 負荷が 4%〜8％になってしまいます。

### マルチディスプレイの壁１

色々検証した結果、Timer の処理が重くなってしまうのは、マルチディスプレイにしている時だと判明しました。マルチディスプレイでは、ディスプレイのそれぞれにメニューバーがあり、アイコンが並ぶため、簡単にいえば、ディスプレイの枚数だけ猫が走ることになるわけです。で、重大なのが、メインのディスプレイ（フォーカスが当たっているもの）上のオブジェクトのコピーを作ってサブのディスプレイにレンダリングされる仕組みの都合上、余計に CPU に負荷がかかるみたいです。ディスプレイを複数使うユーザは稀かもしれませんが、自分自身がそのユーザなので見逃せない負の仕様でした。

### CAKeyframeAnimation で軽量なアニメーション！

そこで、使うことにしたのが CAKeyframeAnimation です。簡単に説明すると、使い方を工夫すれば複数の画像とそのインターバルを設定すると自動でコマ送りアニメーションしてくれるやつです。しかも、途中でアニメーションのスピードを変更することもできます。また、こいつはかなり軽量にアニメーションをすることができるもので、RunCat の場合はアニメーションにかかる CPU 負荷は基本 0.1%です。なぜ、軽量かというと、Core Animation を使ったアニメーションは GPU を用いるためらしいです。

### マルチディスプレイの壁 2

しかし、またしてもマルチディスプレイに障害発生です！なんと、CAKeyframeAnimation はフォーカスの当たっている方のディスプレイでしか動かなかったのです（原因不明でたぶん仕様）。そのあと、軽量なアニメーションを求めて、Stats 系アプリ最強[MenuBar Stats](https://www.seense.com/menubarstats/)の開発者の seense さんに FaceBook で英語凸してヒントをもらい（結局アプリの仕様が違うので役には立たなかったけれど）、結局うまく動かせなかったので、しかたなく眠っている猫の画像を配置することにしました（意外と見つけた人からは高評価）。

![Screen Shot 2019-12-25 at 0.31.13.png](./images/article/fc5eca55-5984-4703-f592-e32f317bf0fa.png)

### なんで dGPU くん勝手に仕事するん？

アニメーションは解決しただろうと思っていた矢先にこんなレビューがきました。

> 「MacBook Pro 15 インチだと dGPU 使って発熱するんだけど。」

まじか...MacBook Pro 13 インチマンだから気づけなかった...

ということで、端末がない限り再現もできない負の仕様をどうやって解決するか途方にくれながら、dGPU を使わない方法を模索すること 3,4 ヶ月...ソースコードではなく`info.plist`から解決する方法を発見しました。`Supports Automatic Graphics Switching`という Key を追加して、Value に`YES`を入れると、勝手に dGPU を使わずに、CPU 内 GPU を使うようになるらしいです。これで発熱問題が解決したかはわかりませんが、クレームが来なくなったので多分大丈夫なのでしょう。

## ライトモードとダークモードの対応むっず

macOS（のメニューバー）には iOS よりも早くからダークモード的な概念がありました。
ここでの課題は

- モードの切り替わりを正確に検出しないと猫が見えなくなってしまう
- ただ白黒反転すれば良いってもんじゃない！キャラクターによってはモードによって別の画像が必要！

という２点でした。
特に 1 個目のやつは、Catalina からオートモードという自動でライトモードとダークモードを切り替えるやつが出てきてめちゃくちゃ面倒なことになりました。これについては Twitter でぼやいたところ、[CotEditor](https://coteditor.com/)の現開発者の@1024jp さんからアドバイスをいただき解決しました。`NSStatusBarButton`の`effectiveAppearance`を observe することで、モードの切り替わりを正確に検出できます。

また、２つ目については普通にそれぞれのモード用の画像を用意して使い分けるようにしました。基本的に Runner は 5 枚の画像で構成されるので、モード毎に画像が必要な Runner は倍の 10 枚の画像リソースを必要としていることになりますね。

![Screen Shot 2019-12-25 at 0.53.53.png](./images/article/15ecfbe0-42a7-5544-de53-de91490efb84.png)

↑ こんな感じ

## 解像度問題：画像サイズとピクセルサイズって違う概念なのね

RunCat の Runner は Retina ディスプレイ用の解像度 2 倍サイズを基準として、縦 36px、横 10px~200px の画像を用いることになっているのですが、色の反転や左右の反転などそのまま使うのではなく、間に加工を挟んでからディスプレイに表示しています。そこで色々厄介な問題が発生するのですが、詳しくは下記の記事を読んでみてください。

[Swift/Xcode：Image Assets の@2x,@3x 画像をコードでリサイズするときは注意しろよな ☺️](https://qiita.com/Kyome/items/2ecc41aabd8f44b72422)

## コンピュータのシステムインフォメーション取ってくるの難しくない？？

> 「僕はただアクティビティモニタに出ている情報を取ってきたかっただけなんだ...」

本当は猫がメニューバーで走っているだけで満足だったのですが、CPU 負荷以外にも色々見られるようにしてほしいという要望が多数あったので、メモリパフォーマンスやディスク容量を表示できるようにすることにしました。しかし、まぁ、本当に前例が少ない。しかも見つけたと思ったら iOS のアプリ単体に関する情報の取得だったり、App SandBox の範囲内でできない手法だったり... 結局執念でコツコツ探しては試して情報を取得できるようになりました。こんな苦労は僕だけで良いという思いで、もしかするとコピーアプリを作られてしまうリスクはありますが、システム情報を取得する手法を記事にまとめて公開しています！

- [Swift：mac の CPU 使用率を取得する](https://qiita.com/Kyome/items/0f640ff03b9018c5369a)
- [Swift：mac のディスク使用量を取得する](https://qiita.com/Kyome/items/2d2161a5cf8a1d3a56f0)
- [Swift：mac のメモリパフォーマンスを取得する](https://qiita.com/Kyome/items/01cce674f7c9d9092a14)
- [Swift：mac のネットワーク上り下りスピードを取得する](https://qiita.com/Kyome/items/e9f56432fa0d1d3f3165)
- [Swift：mac の IP Address を取得する](https://qiita.com/Kyome/items/88d82bd38bf981494f63)
- [↑ これらの集大成](https://qiita.com/Kyome/items/33a667c518eec1ce8e4c)

## プライマリーキーを２つ持たせちゃだめよ

RunCat はもともと無料だった頃、Runner 一体ずつ数字の ID を割り振っていたのですが、有料化した時に App 内課金側の ID が紐づくようになりました。そのせいで、プライマリーキーが２つある状態が長らく続いており、Runner オブジェクトを初期化する方法を２通り用意する必要があり、Runner を管理するのが面倒でした。今では、App 内課金側の ID で統一してプライマリーキーを１本化しました。

## あれ？自作フォントが読み込めない...

~~RunCat の CPU やメモリ情報を表示しているところのアイコンは、実はフォントで表示しています。メニューバー上で頻繁に更新される表示は文字列を用いたほうが楽だと判断したからです。そこで、専用のフォントを作成して使っています。ただ、iOS での自作フォントの読み込みは前例記事がいっぱいあるのですが、macOS はありませんでした。これも記事まとめてあります。~~ 現在のバージョンではフォントは使用していません。
[macOS 向けアプリでカスタムフォントを扱う方法](https://qiita.com/Kyome/items/c52ebf61384e7d5e8b34)

![Screen Shot 2019-12-25 at 1.11.12.png](./images/article/a0f73c00-2b28-1f90-700a-95879269c6d5.png)

# 最後に

RunCat を愛用してくださっているユーザの方々、本当にありがとうございます。皆様の応援に励まされて RunCat のメンテナンスは成り立っております。私も末長く愛されるアプリケーションになるよう尽力しますので、今後も RunCat をよろしくお願いいたします。

# 参考

[RunCat 開発に基づく知見](https://qiita.com/Kyome/items/f0066609b99b4b910a86)
↑ ここにある情報を集約すれば、あなたにもきっと RunCat が 0 から作れます。
